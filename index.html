<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Excel Reverse-Engineer ‚Äî Offline (No API Keys)</title>
  <meta name="description" content="Extract data from chart/table PNGs to Excel (client-side, no API keys)" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üìä</text></svg>">
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React (UI only) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <!-- SheetJS for Excel -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <!-- Tesseract.js (WASM OCR, no keys) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <!-- OpenCV.js (image ops in-browser) -->
  <script async src="https://docs.opencv.org/4.9.0/opencv.js" onload="cv['onRuntimeInitialized']=()=>{window._cvReady=true;}"></script>
  <style>
    @keyframes spin-slow{to{transform:rotate(360deg)}}
    .spin-slow{animation:spin-slow 2s linear infinite}
    .mono{font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
  </style>
</head>
<body class="bg-gradient-to-br from-blue-50 via-indigo-50 to-purple-50">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // --- SVG icons ---
    const Icon = ({path,className}) => (
      <svg className={className||"w-5 h-5"} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d={path}/></svg>
    );
    const icoUpload="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4 M7 8l5-5 5 5M12 3v12";
    const icoFile="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z";
    const icoWarn="M12 9v4 M12 17h.01 M10.29 3.86L1.82 18a2 2 0 001.71 3h16.94a2 2 0 001.71-3L13.71 3.86a2 2 0 00-3.42 0z";

    function App(){
      const [file,setFile]=useState(null);
      const [preview,setPreview]=useState(null);
      const [status,setStatus]=useState('idle'); // idle|processing|success|error
      const [msg,setMsg]=useState('');
      const [rows,setRows]=useState([]); // flattened rows [ [Label,Value], ... ]
      const [meta,setMeta]=useState({chartType:'unknown',title:'',notes:''});
      const [stats,setStats]=useState(()=>JSON.parse(localStorage.getItem('ex-stats')||'{"total":0,"success":0}'));
      const imgRef=useRef();

      useEffect(()=>localStorage.setItem('ex-stats',JSON.stringify(stats)),[stats]);

      const onPick=e=>{
        const f=e.target.files?.[0];
        if(!f || f.type!=="image/png"){ setStatus('error'); setMsg('Please select a PNG image.'); return;}
        setFile(f); setMsg(''); setStatus('idle'); setRows([]); setMeta({chartType:'unknown',title:'',notes:''});
        const r=new FileReader(); r.onload=ev=>setPreview(ev.target.result); r.readAsDataURL(f);
      };

      const waitForCV = () => new Promise((res,rej)=>{
        let t=0; const h=setInterval(()=>{
          if(window._cvReady){clearInterval(h); res();}
          t+=100; if(t>8000){clearInterval(h); rej(new Error("OpenCV failed to initialize")); }
        },100);
      });

      const dataURLToMat = async (dataURL) => {
        const img = new Image(); img.src=dataURL;
        await img.decode();
        const canvas=document.createElement('canvas'); canvas.width=img.naturalWidth; canvas.height=img.naturalHeight;
        const ctx=canvas.getContext('2d'); ctx.drawImage(img,0,0);
        const src=cv.imread(canvas); return {img,canvas,src};
      };

      // --- Detection helpers (simple, robust-first) ---
      const detectTable = (src) => {
        try{
          const gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY,0);
          const bw=new cv.Mat(); cv.adaptiveThreshold(gray,bw,255,cv.ADAPTIVE_THRESH_MEAN_C,cv.THRESH_BINARY_INV,15,8);
          const kernelH=cv.getStructuringElement(cv.MORPH_RECT,new cv.Size(25,1));
          const kernelV=cv.getStructuringElement(cv.MORPH_RECT,new cv.Size(1,25));
          const h=new cv.Mat(); const v=new cv.Mat();
          cv.morphologyEx(bw,h,cv.MORPH_OPEN,kernelH);
          cv.morphologyEx(bw,v,cv.MORPH_OPEN,kernelV);
          const grid=new cv.Mat(); cv.bitwise_or(h,v,grid);
          const count=cv.countNonZero(grid);
          [gray,bw,kernelH,kernelV,h,v,grid].forEach(m=>m.delete());
          return count>2000; // heuristic
        }catch{ return false; }
      };

      const detectPie = (src) => {
        try{
          const gray=new cv.Mat(); cv.cvtColor(src,gray,cv.COLOR_RGBA2GRAY,0);
          const blur=new cv.Mat(); cv.medianBlur(gray,blur,5);
          const circles=new cv.Mat(); cv.HoughCircles(blur,circles,cv.HOUGH_GRADIENT,1.2,80,100,30,40,0);
          const has = circles.rows>0;
          [gray,blur,circles].forEach(m=>m.delete());
          return has;
        }catch{ return false; }
      };

      const extractOCR = async (canvas, psm=6) => {
        const worker = await Tesseract.createWorker('eng', 1, {
          logger: m => {} // no-op
        });
        // set pagesegmode
        await worker.setParameters({ tessedit_pageseg_mode: String(psm) });
        const { data:{ text } } = await worker.recognize(canvas);
        await worker.terminate();
        return text || "";
      };

      const parsePiePairs = (text) => {
        const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
        const out=[];
        for(const line of lines){
          if(line.includes('%')){
            const m = line.match(/([0-9]+(?:\.[0-9]+)?)/);
            if(m){
              const v = Math.round(parseFloat(m[1]));
              let label = line.replace(m[0],'').replace('%','').replace(/[-‚Ä¢:‚Äî]/g,' ').trim();
              if(!label) label='Slice';
              out.push([label, v]);
            }
          }
        }
        return out;
      };

      const parseTable = (text) => {
        // Conservative: split by lines; then by tabs; fallback commas/spaces
        const lines = text.split(/\r?\n/).map(s=>s.trim());
        const dense = lines.filter(s=>s).length/Math.max(lines.length,1) > 0.5;
        const rows=[];
        for(let raw of lines){
          if(!raw) continue;
          let cells = raw.split('\t');
          if(cells.length<2) cells = raw.split(/\s{2,}| \| /); // double-space or pipes
          rows.push(cells.map(c=>c.trim()));
        }
        // sanitize: ensure at least 2 columns somewhere
        const maxCols = rows.reduce((m,r)=>Math.max(m,r.length),0);
        if(maxCols<2) return null;
        return rows;
      };

      const extract = async () => {
        if(!file || !preview) return;

        setStatus('processing'); setMsg('Analyzing image (offline)‚Ä¶');

        try{
          await waitForCV();
          const {canvas,src} = await dataURLToMat(preview);

          // baseline OCR (one pass)
          setMsg('Reading text‚Ä¶');
          const baseText = await extractOCR(canvas, 6);

          // TABLE?
          let bestRows=null; let chartType='unknown'; let notes=[];
          if(detectTable(src)){
            setMsg('Detected grid‚Ä¶ extracting table cells‚Ä¶');
            const tableRows = parseTable(baseText);
            if(tableRows && tableRows.length){
              const header = tableRows[0].length>=2 ? tableRows[0] : ['Column 1','Column 2'];
              bestRows = [header, ...tableRows.slice(1)];
              chartType='table';
            }
          }

          // PIE?
          if(!bestRows && detectPie(src)){
            setMsg('Detected circular plot‚Ä¶ reading % labels‚Ä¶');
            const pairs = parsePiePairs(baseText);
            if(pairs.length){
              bestRows = [['Category','Value(%)'], ...pairs];
              chartType='pie';
            }else{
              notes.push('Pie detected but % labels unreadable; data omitted.');
            }
          }

          // BAR/COLUMN? (fallback = collect numeric lines)
          if(!bestRows){
            setMsg('Looking for numeric series‚Ä¶');
            // scan lines, pair label+value when pattern like "<label> ... <number>"
            const lines = baseText.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
            const guessed=[];
            for(const line of lines){
              const m = line.match(/^(.*?)[\s:‚Ä¢-]{1,}\s*([0-9][0-9,\. ]*)$/);
              if(m){
                const label = m[1].trim();
                const val = parseFloat(m[2].replace(/,/g,''));
                if(label && isFinite(val)) guessed.push([label, val]);
              }
            }
            if(guessed.length){
              bestRows = [['Label','Value'], ...guessed];
              chartType='series';
              notes.push('Series values inferred from label:number lines; no tick interpolation (browser-safe).');
            }
          }

          // If nothing, at least dump numbers we saw
          if(!bestRows){
            const nums = [...baseText.matchAll(/[0-9][0-9,\. ]*/g)].map(m=>m[0]);
            if(nums.length){
              bestRows = [['Index','Value'], ...nums.map((n,i)=>[String(i+1), parseFloat(n.replace(/,/g,''))])];
              chartType='numbers';
              notes.push('Structure not recognized; returned numeric tokens only.');
            }else{
              bestRows = [['Note'],['No recognizable chart/table structure detected.']];
              chartType='unknown';
            }
          }

          setRows(bestRows);
          setMeta({chartType, title:file.name.replace(/\.png$/i,''), notes:notes.join(' ')});
          setStatus('success'); setMsg('Data extracted. You can download Excel now.');
          setStats(s=>({total:s.total+1, success:s.success+1}));

          // clean up
          src.delete();

        }catch(err){
          console.error(err);
          setStatus('error'); setMsg(err.message || 'Extraction error.');
          setStats(s=>({total:s.total+1, success:s.success}));
        }
      };

      const downloadExcel = () => {
        if(!rows || rows.length===0){ setStatus('error'); setMsg('Nothing to export.'); return; }

        const wb = XLSX.utils.book_new();

        // Data sheet
        const ws = XLSX.utils.aoa_to_sheet(rows);
        ws['!cols'] = Array.from({length: rows[0]?.length||2}, ()=>({wch: 28}));
        XLSX.utils.book_append_sheet(wb, ws, 'Data');

        // Summary sheet
        const now = new Date().toISOString();
        const summary = [
          ['Excel Reverse-Engineer (Offline)'],
          [],
          ['Chart Type', (meta.chartType||'').toUpperCase()],
          ['Extracted', now],
          ['Source PNG', file?.name || ''],
          ['Rows', rows.length-1],
          meta.notes ? [] : null,
          meta.notes ? ['Notes', meta.notes] : null
        ].filter(Boolean);
        const ws2 = XLSX.utils.aoa_to_sheet(summary);
        ws2['!cols']=[{wch:16},{wch:60}];
        XLSX.utils.book_append_sheet(wb, ws2, 'Summary');

        const outName = (file?.name||'extraction').replace(/\.png$/i,'') + '_data.xlsx';
        XLSX.writeFile(wb, outName);
        setMsg('Excel downloaded.');
      };

      return (
        <div className="max-w-6xl mx-auto px-4 py-8">
          <header className="bg-white border rounded-xl p-4 flex items-center justify-between shadow-sm">
            <div className="flex items-center gap-3">
              <Icon path={icoFile} className="w-7 h-7 text-indigo-600" />
              <div>
                <h1 className="text-2xl font-bold text-gray-900">Excel Reverse-Engineer (No API Keys)</h1>
                <p className="text-sm text-gray-600">All processing is client-side with Tesseract.js + OpenCV.js</p>
              </div>
            </div>
            <a className="text-indigo-600 hover:underline" href="./" aria-label="Reload">Reload</a>
          </header>

          <main className="mt-6 space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <div className="bg-white p-5 rounded-xl shadow-sm">
                <h3 className="font-semibold mb-2">Bar/Column</h3>
                <p className="text-sm text-gray-600">Reads <span className="mono">Label : Number</span> lines via OCR.</p>
              </div>
              <div className="bg-white p-5 rounded-xl shadow-sm">
                <h3 className="font-semibold mb-2">Pie</h3>
                <p className="text-sm text-gray-600">Detects circle + % labels; rounds to nearest 1%.</p>
              </div>
              <div className="bg-white p-5 rounded-xl shadow-sm">
                <h3 className="font-semibold mb-2">Tables</h3>
                <p className="text-sm text-gray-600">Detects gridlines; extracts cells line-by-line.</p>
              </div>
            </div>

            <div className="bg-white p-8 rounded-xl shadow-md">
              <div className="border-2 border-dashed border-indigo-300 rounded-xl p-10 text-center">
                <input id="pick" className="hidden" type="file" accept="image/png" onChange={onPick} />
                <label htmlFor="pick" className="cursor-pointer select-none">
                  <Icon path={icoUpload} className="w-12 h-12 text-indigo-400 mx-auto mb-3"/>
                  <div className="text-lg font-semibold text-gray-700">Drop PNG or click to upload</div>
                  <div className="text-sm text-gray-500">Works entirely offline in your browser</div>
                </label>
              </div>

              {preview && (
                <div className="mt-6">
                  <div className="text-sm text-gray-600 mb-2">Preview:</div>
                  <div className="border rounded-lg overflow-hidden">
                    <img ref={imgRef} alt="preview" src={preview} className="max-h-[420px] w-auto mx-auto" />
                  </div>
                  <div className="text-xs text-gray-500 mt-1">{file?.name}</div>
                </div>
              )}
            </div>

            {file && (
              <div className="bg-white p-6 rounded-xl shadow-md flex flex-col sm:flex-row gap-3">
                <button onClick={extract} disabled={status==='processing'} className="flex-1 px-5 py-3 rounded-lg text-white font-semibold bg-indigo-600 hover:bg-indigo-700 disabled:bg-gray-400">
                  {status==='processing' ? 'Processing‚Ä¶' : 'Extract Data (Offline)'}
                </button>
                {rows.length>0 && (
                  <button onClick={downloadExcel} className="flex-1 px-5 py-3 rounded-lg text-white font-semibold bg-green-600 hover:bg-green-700">
                    Download Excel
                  </button>
                )}
              </div>
            )}

            {msg && (
              <div className={`p-4 rounded-lg border ${status==='error'?'bg-red-50 border-red-200 text-red-700': status==='success'?'bg-green-50 border-green-200 text-green-700':'bg-blue-50 border-blue-200 text-blue-700'}`}>
                <div className="flex items-start gap-2">
                  <Icon path={status==='error'?icoWarn:icoFile} className={status==='processing'?'spin-slow':''}/>
                  <p>{msg}</p>
                </div>
              </div>
            )}

            {rows.length>0 && (
              <div className="bg-white p-6 rounded-xl shadow-md">
                <h3 className="text-xl font-semibold text-gray-800 mb-3">Extracted Data Preview</h3>
                <div className="text-sm text-gray-600 mb-2">
                  Type: <span className="font-semibold">{meta.chartType.toUpperCase()}</span>
                </div>
                <div className="overflow-auto">
                  <table className="min-w-full border border-gray-200">
                    <thead>
                      <tr className="bg-indigo-600 text-white">
                        {rows[0].map((h,i)=>(<th key={i} className="px-3 py-2 text-left border border-indigo-700">{h||`Col ${i+1}`}</th>))}
                      </tr>
                    </thead>
                    <tbody>
                      {rows.slice(1).map((r,ri)=>(
                        <tr key={ri} className={ri%2===0?'bg-gray-50':''}>
                          {r.map((c,ci)=>(<td key={ci} className="px-3 py-2 border border-gray-200">{String(c)}</td>))}
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
                {meta.notes && <p className="mt-3 text-sm text-yellow-800 bg-yellow-50 border border-yellow-200 rounded p-2">Note: {meta.notes}</p>}
              </div>
            )}

            <div className="bg-white p-6 rounded-xl shadow-sm text-sm text-gray-700">
              <h4 className="font-semibold mb-2">Notes & Limitations (transparent, by design)</h4>
              <ul className="list-disc pl-5 space-y-1">
                <li>No servers or API keys. Everything runs in your browser with WebAssembly.</li>
                <li>Pie extraction requires visible ‚Äú%‚Äù labels (we round to nearest 1%).</li>
                <li>Bar/column values use OCR lines like <span className="mono">Label : 123</span>. This avoids risky pixel interpolation that can fabricate numbers.</li>
                <li>Tables work best with clear gridlines and high contrast.</li>
              </ul>
            </div>
          </main>

          <footer className="text-center text-gray-500 text-xs py-6">
            Offline build ‚Ä¢ Tesseract.js + OpenCV.js + SheetJS ‚Ä¢ GitHub Pages ready
          </footer>
        </div>
      );
    }

    ReactDOM.render(<App/>, document.getElementById('root'));
  </script>
</body>
</html>
